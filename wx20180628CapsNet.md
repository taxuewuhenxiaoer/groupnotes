自从听到大组会有个同学讲胶囊网络，很感兴趣，一直想了解胶囊网络CapsNet，也一直没有看，这次报告是讲解胶囊网络。

1、泛化能力

我们经常会看到这个概念，了解一下概念。在机器学习方法中，泛化能力通俗来讲就是指**学习到的模型对未知数据的预测能力**。在实际情况中，我们通常通过测试误差来评价学习方法的泛化能力。

2、胶囊网络原理 https://blog.csdn.net/godwriter/article/details/79216404仅用于学习

在讲胶囊网络之前，首先我们回顾一下我们熟悉的CNN。

<img src="http://ww1.sinaimg.cn/large/9f6c4109ly1fsqo75stkjj20h307jgm6.jpg"/>

CNN做了什么事情呢? 假设这里有一个卷积核（左图），除了曲线轨迹上的值很大，其他的值都是零，所以这个卷积核对旁边这种曲线（右图）就有很高的输出，也就是说对这种曲线有很高的识别，而对其他的曲线类型输出就低。

所以比如图像分类中，一旦卷积核检测到了类似于眼睛啊、鼻子啊、嘴巴啊这种特征；从数学角度上说就，相关卷积核对鼻子、眼睛等卷积出来的值很大，那么与人脸相关的神经元就相当兴奋，最后将图像分类到人脸这一类。

所以这就导致了一个问题。如图，右边那张眼睛、鼻子、嘴巴都有了，当然我们的CNN也相当兴奋的将它归于人脸。

<img src="http://ww1.sinaimg.cn/large/9f6c4109ly1fsqo812k15j20kp0b974s.jpg"/>

这就就暴露了CNN的一个问题：组件的朝向和空间上的相对关系对它来说不重要，它只在乎有没有特征。此外，CNN还有一个问题，那就是池化层。Hinton自己就说过：最大池化层表现的如此优异是一个巨大的错误，是一场灾难。诚然，从网络设计上来说，池化层不仅减少了参数，还可以避免过拟合。但是，它的确抛弃了一些信息，比如位置信息。

再比如说，下面这张图

<img src="http://ww1.sinaimg.cn/large/9f6c4109ly1fsqo8n4kdwj20k008m0th.jpg"/>

尽管拍摄的角度不同，但你的大脑可以轻易的辨识这些都是同一对象，CNN却没有这样的能力。它不能举一反三，它只能通过扩大训练的数据量才能得到相似的能力。

所以，CapsNet应运而生。如图：

<img src="http://ww1.sinaimg.cn/large/9f6c4109ly1fsqo9f614oj20m80adgm8.jpg"/>

上一列和下一列的图片属于同一类，仅仅视角不同。CapsNet和其他模型相比表现就要好很多。据说，最新的论文降低了45%的错误率，这是压倒性的优势。

 

那现在让我们来看一下CapsNet的具体架构。下面的图是论文里面设计的一个简单的CapsNet网络，只用到了一层胶囊，但是却也很好的展现了CapsNet是如何工作的。

<img src="http://ww1.sinaimg.cn/large/9f6c4109ly1fsqoagfnh9j20rs08f3zc.jpg"/>

从上图，我们可以看到，输入是一张手写字的图片。首先对这张图片做了常规的卷积操作，得到ReLU Conv1；然后再对ReLU Conv1做卷积操作，并将其调整成适用于CapsNet的向量神经元层PrimaryCaps（具体如何调整的，鄙人会结合自己对代码的理解在下周会议上讲解），而不是以往的标量神经元。

PrimaryCaps到DigitCaps层的传播也就是CapsNet和以往CNN操作的最大区别，本文的提出的算法：动态路由算法，也就运用在这一过程之中，具体计算会在下面讲到。

最后，DigitCaps中一共10个向量，每个向量中元素的个数为16。对这10个向量求模，求得模值最大的那个向量代表的就是图片概率最大的那个分类。因为胶囊网络中：用向量模的大小衡量某个实体出现的概率，模值越大，概率越大。

现在，让我们来讲一下如何使用动态路由算法，完成从PrimaryCaps层到DigitCaps层的转变。

首先，先向大家解释一下鄙人对胶囊的理解：所谓胶囊，就是一个向量，它可包含任意个值，每个值代表了当前需要识别的物体（比如图片）的一个特征。结合之前对传统CNN的学习，我们知道，卷积层的每个值，都是上一层某一块区域和卷积核完成卷积操作，即线性加权求和的结果，它只有一个值，所以是标量。而我们的胶囊网络，它的每一个值都是向量，也就是说，这个向量不仅可表示物体的特征、还可以包括物体的方向、状态等等。

现在假设已经有三个低层的胶囊，然后需要传递到更高层的四个胶囊，如下图：

<img src="http://ww1.sinaimg.cn/large/9f6c4109ly1fsqobku413j20rn0j5aao.jpg"/>

这张图是我结合对动态路由算法的理解画的，每一个小方框都代表一个胶囊。胶囊网络的前向传播和全连接神经网络相似，所以我会从边对比边讲述胶囊网络的前向传播，以便大家有更好的理解。

### 网络连接方式

胶囊网络和全连接网络的连接方式一模一样。前一层每一个胶囊神经单元都会和后一层每一个胶囊神经单元相连，我想大家一看上图我画的一组连线应该就懂了，故不多做讲述。之所以只画一组连线，是为了大家能看的清楚，剩下没画的连线想必大家自己都能想象出来。

### 权重更新

和全连接神经网络一样，胶囊网络的每一个连接也有权重。在上面图中，W代表权重，大家需要注意：C不是权重，它叫耦合系数，我会在下面详细讲解，现在所指的权重只有W。在全连接神经网络中，每一个神经元都是标量，即都只有一个数字值，故每个权重也都只是一个标量，也是一个数字值。

但在胶囊网络中，每一个胶囊神经元都是向量，即包含多个值（如[x1, x2, x3, ..., xn], 具体个数n根据网络设计得到），所以每个胶囊神经元的权值W也应该是一个向量。W依旧根据反向传播来更新。

### 网络的输入

全连接神经网络的输入即线性加权求和，胶囊网络很类似，但是它在线性求和阶段上多加了一个耦合系数C。胶囊网络的输入S由下面公式得到：

<img src="http://ww1.sinaimg.cn/large/9f6c4109ly1fsqocj3e5bj20ds02z74c.jpg"/>

其中u是上一层胶囊网络的输出，W是每个输出要乘的权值，可以看作上一层每一个胶囊神经元以不同强弱的连接输出到后一层的某一个神经元。C根据下面公式计算：

<img src="http://ww1.sinaimg.cn/large/9f6c4109ly1fsqod18uaxj209a03nwem.jpg"/>

C叫做耦合系数。为了求C我们必须先求b，b根据下面公式计算：

<img src="http://ww1.sinaimg.cn/large/9f6c4109ly1fsqodli0vfj205a0100sj.jpg"/>

b初始值为0。故在前向传播求S的过程中，我们把W设计成随机值，b初始化为0可以得到C，u就是上一层胶囊网络的输出，有了三这个值，我们就可以得到下一层的S。

 

### 激活函数

在全连接神经网络中，我们选择的激活函数通常为：sigmoid, tanh等。但在胶囊网络中，Hinton构造了新的激活函数Squashing，故输出V的计算如下图所示：

<img src="http://ww1.sinaimg.cn/large/9f6c4109ly1fsqoe6h9o3j209l03yjrf.jpg"/>

该激活函数前一部分是输入输入向量S的缩放尺度，后一部分是S的单位向量。该激活函数既保留了输入输入向量的方向，又将输入向量的模压缩到[0, 1）之间。这也符合了我们前面说的：用向量模的大小衡量某个实体出现的概率，模值越大，概率越大。

 

### 动态路由更新b，来更新c

这一点是胶囊网络的精华了。前面我们的b初始化为0，得到的耦合系数C趋于一般化，并不能表现出前一层的胶囊和后一层胶囊的之间的关系。故我们需要更新b，通过b的更新来更新C，b更新公式就是：

<img src="http://ww1.sinaimg.cn/large/9f6c4109ly1fsqoeucoobj205a0100sj.jpg"/>

本论文通过计算内积来改变b，来改变C。那为什么要这么做呢，网上有很多解释，我更欣赏下面的这种解释，也和我自己的理解相似：

<img src="http://ww1.sinaimg.cn/large/9f6c4109ly1fsqoffl8crj20go08g3yq.jpg"/>

点积运算接收两个向量，并输出一个标量。对于给定长度但方向不同的的两个向量而言，点积有下列几种情况：正值、零、负值。故当u_hat和v的相乘结果为正时，代表两个向量指向的方向相似，b更新结果变大，那么耦合系数就高，说明该u_hat和v十分匹配。相反，若是u_hat和v相乘结果为负，b更新结果变小，那么耦合系数就小，说明不匹配。通过迭代确定C，也就等于确定了一条路线，这条路线上胶囊神经元的模都特别大，路线的尽头就是那个正确预测的胶囊。

根据论文描述，b的迭代更新次数取值为3比较好。

整个动态路由算法如下图所示：

<img src="http://ww1.sinaimg.cn/large/9f6c4109ly1fsqog6v0j8j213j0bmdgh.jpg"/>

首先，将所有的b初始化为0，然后开始迭代。每次迭代先通过softmax求出C值，然后结合U，W，C，做线性求和得到S，再将S输入激活函数Squashing得到V，最后利用U_hat和V来完成b值的更新。一切计算结束后，开始下一步迭代，迭代次数设置3为佳。

 

除了耦合系数C是通过动态路由更新的，整个网络其他的卷积参数和Capusle内的W都需要根据损失函数进行更新。在原论文中，作者采用SVM中常用的Margin Loss，表达式如下：

<img src="http://ww1.sinaimg.cn/large/9f6c4109ly1fsqogscohdj20r901xt91.jpg"/>

具体参数含义PPT上有写。

 

重构的意思就是用预测的类别重新构建出该类别代表的实际图像。前面，我们说到Capsule的向量可以表征一个实例，那么将最后的那个正确预测类别的向量投入到后面的重构网络中，应该可以构建一个完整的图像。

故Hinton等人使用额外的重构损失来促进DigitCaps层对输入数字图片进行编码。重构网络架构如下：

<img src="http://ww1.sinaimg.cn/large/9f6c4109ly1fsqohcd8scj20lv09mq4h.jpg"/>

上图表明，正确预测类别的向量，即模值最大的向量送入包含三个全连接层的网络解码。这一过程的损失函数通过计算FC Sigmoid层的输出像素商店与原始图像像素点的欧氏距离而构建。

这张图是拿MNIST做实验得到的结果。

<img src="http://ww1.sinaimg.cn/large/9f6c4109ly1fsqohv7wzaj20qt07jwev.jpg"/>

L代表标签，p代表预测值，r重构出的图片。左边三列是正确的结果。大家可以看到重构出来的图像形状和位置和输入极其类似，这是说明胶囊网络起了作用，即一个Capsule的确包含了物体的多个信息：特征、位置、大小等等。而后面两列是预测失败的，通过重构出来的图我们可以得到原因：3和5太像了，我感觉Hinton的意思就是，这种图人也会犯错，不怪Capsule。

 <img src="http://ww1.sinaimg.cn/large/9f6c4109ly1fsqoifluzyj20o509mq5r.jpg"/>

泛化能力对模型无比重要，故Hinton对原来的MNIST数据集做了改变（大小、粗细、位置，如上图）并传入一个训练过的，测试准确率为99.23%的Capsule模型做测试，得到准确率为79%。而一个训练过的准确度为99.22%的传统CNN模型只能达到66%的准确率。不得不说，Capsule模型的泛化能力的确惊人。

<img src="http://ww1.sinaimg.cn/large/9f6c4109ly1fsqoizv45xj20i80altam.jpg"/>

Hinton在论文中花了大量的笔墨来解释他们做的数字重叠分类实验，他们的模型错误率达到了5%。说实话，感觉Hinton做这个实验来验证Capsule的强大有些欠缺，有点强买强卖的感觉。

但是有值得一提的是，Capsule能重构两个数字虽然他们重叠在一起。进一步理解应该是，Capsule中的两个向量能完整表达两个数字的特征，虽然有些特征重叠在一起导致难以分辨。

结语：好的知识一起分享。为了看懂CapsNet，我参考了很多大佬的文章才能最后得到这篇文章，若是侵权，在下马上删除此文。谢谢业界前辈引路！



